Codigo-organizador-horario
"""
Proyecto: Organizador de horarios universitarios (Avance combinado)

Incluye:
1) Vista ORIGINAL por días (diccionario de listas) del primer avance:
   - Registrar materias
   - Ver materias (crudo)
   - Acomodo automático por días (máx. 5h/día + posibles descansos)
   - Acomodo manual por días
   - Mostrar acomodo por días

2) Vista NUEVA con MATRIZ semanal (5 x SLOTS) y TAREAS:
   - Matriz de CLASES (automático y manual)
   - Registro y listado de TAREAS
   - Calendario COMBINADO (clases + tareas)

Además:
- Comentarios multilínea arriba de cada función
- Nombres en snake_case
"""

from datetime import datetime
from copy import deepcopy

# ------------------------------ CONSTANTES ---------------------------------

DIAS = ["Lunes", "Martes", "Miércoles", "Jueves", "Viernes"]
SLOTS_POR_DIA = 8
MAX_CLASES_POR_DIA = 5
LIBRE = "LIBRE"
DESCANSO = "DESCANSO"

# ------------------------------ AYUDANTES ----------------------------------

"""
Normaliza el texto de entrada para que coincida con un día válido.
Acepta “miercoles” sin acento como “Miércoles”; si es inválido, usa “Lunes”.
"""
def normaliza_dia(entrada: str) -> str:
    if not entrada:
        return "Lunes"
    e = entrada.strip().capitalize()
    if e.startswith("Mier"):
        return "Miércoles"
    if e not in DIAS:
        return "Lunes"
    return e

"""
Devuelve el índice [0..4] del día en la lista DIAS.
"""
def indice_dia(dia: str) -> int:
    return DIAS.index(dia)

# ========================== PRIMER AVANCE (DÍAS) ============================

"""
Registra materias y horas semanales.
Se guarda como lista de diccionarios: {"nombre": str, "horas_semanales": int}.
"""
def registrar_clases() -> list[dict]:
    materias = []
    n = int(input("¿Cuántas materias deseas registrar? "))
    for i in range(n):
        nombre = input(f"Materia {i+1}: ").strip() or f"Materia_{i+1}"
        horas = int(input(f"Horas semanales de {nombre}: "))
        materias.append({"nombre": nombre, "horas_semanales": horas})
    return materias

"""
Muestra el listado de materias registradas y sus horas.
"""
def mostrar_clases(materias: list[dict]) -> None:
    print("\n--- Horario de Clases (crudo) ---")
    if not materias:
        print("No hay materias registradas.")
    for m in materias:
        print(f"{m['nombre']}: {m['horas_semanales']} horas/semana")
    print()

"""
Convierte la estructura de materias (list[dict]) a una lista de tuplas (nombre, horas)
para compatibilidad con el esquema del primer avance por días.
"""
def materias_a_tuplas(materias: list[dict]) -> list[tuple[str, int]]:
    return [(m["nombre"], int(m["horas_semanales"])) for m in materias]

"""
Acomodo AUTOMÁTICO en estructura por DÍAS (diccionario de listas),
respetando máximo 5 clases por día y colocando “DESCANSO” ocasionalmente.
Devuelve: {"Lunes": [...], ...}
"""
def acomodo_automatico_dias(materias: list[dict]) -> dict:
    dias = {"Lunes": [], "Martes": [], "Miércoles": [], "Jueves": [], "Viernes": []}
    horas_dia = {d: 0 for d in dias}
    i = 0
    tuplas = materias_a_tuplas(materias)
    total_horas = sum(h for _, h in tuplas)

    for materia, horas in tuplas:
        while horas > 0:
            dia = list(dias.keys())[i % 5]
            if horas_dia[dia] < MAX_CLASES_POR_DIA:
                # pausa simple tras 2 clases seguidas si hay espacio y tiempo
                if (len(dias[dia]) >= 2 and
                    dias[dia][-1] != "DESCANSO" and
                    dias[dia][-2] != "DESCANSO" and
                    horas_dia[dia] <= 3 and
                    total_horas > 0):
                    dias[dia].append("DESCANSO")
                else:
                    dias[dia].append(materia)
                    horas_dia[dia] += 1
                    horas -= 1
                    total_horas -= 1
            else:
                i += 1  # pasar al siguiente día
        i += 1
    return dias

"""
Acomodo MANUAL en estructura por DÍAS (diccionario de listas).
Pide día al usuario y respeta el límite de 5 clases por día.
"""
def acomodo_manual_dias(materias: list[dict]) -> dict:
    dias = {"Lunes": [], "Martes": [], "Miércoles": [], "Jueves": [], "Viernes": []}
    horas_dia = {d: 0 for d in dias}

    for m in materias:
        materia, horas = m["nombre"], int(m["horas_semanales"])
        print(f"\nAcomodo manual para {materia} ({horas} h/semana)")
        dia = normaliza_dia(input("Elige día (Lunes/Martes/Miércoles/Jueves/Viernes): "))

        while horas > 0:
            if horas_dia[dia] < MAX_CLASES_POR_DIA:
                dias[dia].append(materia)
                horas_dia[dia] += 1
                horas -= 1
            else:
                print(f"{dia} ya tiene {MAX_CLASES_POR_DIA} horas. Elige otro día.")
                dia = normaliza_dia(input("Día alterno: "))
    return dias

"""
Imprime el acomodo por DÍAS (diccionario) como en el primer avance.
"""
def mostrar_acomodo(dias: dict) -> None:
    print("\n--- Horario por día (vista original) ---")
    for d in ["Lunes", "Martes", "Miércoles", "Jueves", "Viernes"]:
        print(f"{d}: {dias[d]}")
    print()

# ======================= NUEVO MÓDULO (MATRICES + TAREAS) ===================

"""
Construye una matriz 5 x SLOTS_POR_DIA inicializada con "LIBRE".
"""
def construir_matriz_vacia() -> list[list[str]]:
    return [[LIBRE for _ in range(SLOTS_POR_DIA)] for _ in range(len(DIAS))]

"""
Cuenta clases consecutivas al final de una fila (día) de la matriz.
Se usa para decidir insertar descansos.
"""
def consecutivos_clases_al_final(fila: list[str]) -> int:
    count = 0
    for celda in reversed(fila):
        if celda in (LIBRE, DESCANSO):
            break
        count += 1
    return count

"""
Cuenta cuántas clases reales hay en una fila (ignora LIBRE, DESCANSO y TAREA).
"""
def contar_clases_en_dia(fila: list[str]) -> int:
    total = 0
    for c in fila:
        if c not in (LIBRE, DESCANSO) and not str(c).startswith("TAREA:"):
            total += 1
    return total

"""
Imprime una matriz semanal de forma tabular con encabezados de slot.
"""
def imprimir_matriz(matriz: list[list[str]], titulo: str = "Matriz semanal") -> None:
    print(f"\n--- {titulo} ---")
    header = "Slot | " + " | ".join([f"{i:02d}" for i in range(SLOTS_POR_DIA)])
    print(header)
    print("-" * len(header))
    for d_idx, dia in enumerate(DIAS):
        fila = matriz[d_idx]
        contenido = " | ".join(f"{c[:10]:10}" for c in fila)
        print(f"{dia[:3]}  | {contenido}")
    print()

"""
Genera automáticamente una MATRIZ con clases distribuidas (máx. 5/día) e
inserta descansos tras dos clases seguidas cuando hay espacio.
"""
def acomodo_automatico_matriz(materias: list[dict]) -> list[list[str]]:
    matriz = construir_matriz_vacia()
    dia_idx = 0
    for m in materias:
        nombre, horas = m["nombre"], int(m["horas_semanales"])
        while horas > 0:
            if contar_clases_en_dia(matriz[dia_idx]) < MAX_CLASES_POR_DIA:
                fila = matriz[dia_idx]
                if consecutivos_clases_al_final(fila) >= 2 and LIBRE in fila:
                    fila[fila.index(LIBRE)] = DESCANSO
                if LIBRE in fila:
                    fila[fila.index(LIBRE)] = nombre
                    horas -= 1
            dia_idx = (dia_idx + 1) % len(DIAS)
    return matriz

"""
Permite colocar manualmente las clases en la MATRIZ, respetando 5 por día.
"""
def acomodo_manual_matriz(materias: list[dict]) -> list[list[str]]:
    matriz = construir_matriz_vacia()
    for m in materias:
        nombre, horas = m["nombre"], int(m["horas_semanales"])
        print(f"\nAcomodo manual (matriz) para {nombre} ({horas}h)")
        while horas > 0:
            dia = normaliza_dia(input("Día (Lunes-Viernes): "))
            fila = matriz[indice_dia(dia)]
            if contar_clases_en_dia(fila) < MAX_CLASES_POR_DIA and LIBRE in fila:
                fila[fila.index(LIBRE)] = nombre
                horas -= 1
            else:
                print("Día lleno o sin slots disponibles.")
    return matriz

"""
Registra una tarea con: título, materia, horas estimadas y deadline
(formato: YYYY-MM-DD HH:MM). Devuelve el dict de la tarea.
"""
def registrar_tarea_calendario() -> dict | None:
    titulo = input("Título de la tarea: ").strip() or "Tarea"
    materia = input("Materia: ").strip() or "General"
    horas = int(input("Horas estimadas: "))
    dl_str = input("Fecha límite (YYYY-MM-DD HH:MM): ").strip()
    deadline = datetime.strptime(dl_str, "%Y-%m-%d %H:%M")
    return {"titulo": titulo, "materia": materia, "horas_estimadas": horas, "deadline": deadline}

"""
Muestra las tareas ordenadas por fecha límite.
"""
def mostrar_tareas(tareas: list[dict]) -> None:
    print("\n--- Tareas registradas ---")
    if not tareas:
        print("No hay tareas registradas.")
        return
    for t in sorted(tareas, key=lambda x: x["deadline"]):
        print(f"[{t['deadline']:%Y-%m-%d %H:%M}] {t['titulo']} ({t['materia']}) - {t['horas_estimadas']}h")

"""
Genera una MATRIZ combinada (clases + tareas) colocando bloques de TAREA
en slots LIBRE antes (o el mismo día) del deadline. Si no hay espacio, quedan pendientes.
"""
def generar_calendario_tareas(matriz_clases: list[list[str]], tareas: list[dict]) -> list[list[str]]:
    combinado = deepcopy(matriz_clases)
    if not tareas:
        return combinado
    tareas_ord = sorted(tareas, key=lambda t: t["deadline"])
    for t in tareas_ord:
        horas = int(t["horas_estimadas"])
        materia, titulo = t["materia"], t["titulo"]
        limite = min(4, t["deadline"].weekday())  # L=0 .. V=4
        for d in range(limite + 1):
            if horas <= 0:
                break
            fila = combinado[d]
            for i in range(SLOTS_POR_DIA):
                if horas <= 0:
                    break
                if fila[i] == LIBRE:
                    fila[i] = f"TAREA: {titulo} ({materia})"
                    horas -= 1
        if horas > 0:
            print(f"Aviso: horas de '{titulo}' pendientes por falta de espacio: {horas}")
    return combinado


