"""
Organizador de Horarios Universitarios
"""

from datetime import datetime, timedelta
from copy import deepcopy
import json
from typing import Optional

# ------------------------------ CONSTANTES ---------------------------------

DIAS = ["Lunes", "Martes", "Miércoles", "Jueves", "Viernes"]
SLOTS_POR_DIA = 8
MAX_CLASES_POR_DIA = 5
MAX_TAREAS_POR_DIA = 6
LIBRE = "LIBRE"
DESCANSO = "DESCANSO"

W_DEADLINE = 0.6
W_PRIORIDAD = 0.3
W_DIFICULTAD = 0.1

TIPOS_TAREA = {"TAREA", "ESTUDIO", "PROYECTO", "EXAMEN"}
ENERGIAS = {"BAJA", "MEDIA", "ALTA"}

# ------------------------------ FUNCIONES BASE ------------------------------

"""
Descripción:
Normaliza el nombre de un día a la convención empleada por el sistema.

Algoritmo:
1) Si la entrada es vacía → retornar "Lunes".
2) Limpiar y capitalizar la entrada.
3) Si inicia con "Mier" → retornar "Miércoles".
4) Si no pertenece a DIAS → retornar "Lunes".
5) En otro caso, retornar la entrada validada.
"""
def normaliza_dia(entrada: str) -> str:
    if not entrada:
        return "Lunes"
    e = entrada.strip().capitalize()
    if e.startswith("Mier"):
        return "Miércoles"
    if e not in DIAS:
        return "Lunes"
    return e

"""
Descripción:
Devuelve el índice entero del día dentro del conjunto DIAS.

Algoritmo:
1) Usar DIAS.index(dia) para localizar la posición [0..4].
2) Retornar el índice encontrado.
"""
def indice_dia(dia: str) -> int:
    return DIAS.index(dia)

# ------------------------------ MATERIAS -----------------------------------

"""
Descripción:
Construye la lista de materias a partir de una colección de registros validados.

Algoritmo:
1) Verificar que 'entradas' no sea None (si lo es, lanzar ValueError).
2) Iterar sobre 'entradas':
   a) Tomar nombre (o asignar "Materia_i").
   b) Convertir horas_semanales a int.
   c) Agregar dict normalizado a la salida.
3) Retornar la lista de materias normalizada.
"""
def registrar_clases(entradas: Optional[list[dict]] = None) -> list[dict]:
    if entradas is None:
        raise ValueError("registrar_clases requiere 'entradas'.")
    out = []
    for i, m in enumerate(entradas, 1):
        nombre = (m.get("nombre") or f"Materia_{i}").strip()
        horas = int(m.get("horas_semanales", 0))
        out.append({"nombre": nombre, "horas_semanales": horas})
    return out

"""
Descripción:
Genera una representación legible del catálogo de materias registradas.

Algoritmo:
1) Si 'materias' está vacío → retornar ["No hay materias registradas."].
2) Iniciar con el encabezado.
3) Por cada materia, agregar una línea "Nombre: X horas/semana".
4) Si as_text=True → unir líneas con "\n"; de lo contrario, retornar lista.
"""
def mostrar_clases(materias: list[dict], as_text: bool = False):
    lines = ["--- Horario de Clases ---"] if materias else ["No hay materias registradas."]
    for m in materias:
        lines.append(f"{m['nombre']}: {m['horas_semanales']} horas/semana")
    return "\n".join(lines) if as_text else lines

"""
Descripción:
Convierte la estructura de materias a tuplas (nombre, horas) para su procesamiento.

Algoritmo:
1) Para cada materia, formar la tupla (nombre, int(horas_semanales)).
2) Retornar la lista de tuplas.
"""
def materias_a_tuplas(materias: list[dict]) -> list[tuple[str, int]]:
    return [(m["nombre"], int(m["horas_semanales"])) for m in materias]

"""
Descripción:
Distribuye automáticamente las horas de cada materia en un diccionario por días.

Algoritmo:
1) Inicializar 'dias' como {día: []} y contador 'horas_dia'.
2) Convertir materias a tuplas y calcular total de horas.
3) Para cada (materia, horas):
   a) Mientras queden horas por asignar:
      i) Seleccionar día con índice cíclico i % 5.
      ii) Si el día no supera MAX_CLASES_POR_DIA:
          - Si hay 2 clases previas consecutivas y espacio, insertar DESCANSO.
          - En caso contrario, colocar materia, actualizar contadores.
      iii) Si está lleno, avanzar al siguiente día.
4) Retornar el diccionario 'dias' resultante.
"""
def acomodo_automatico_dias(materias: list[dict]) -> dict:
    dias = {d: [] for d in DIAS}
    horas_dia = {d: 0 for d in dias}
    i = 0
    tuplas = materias_a_tuplas(materias)
    total_horas = sum(h for _, h in tuplas)

    for materia, horas in tuplas:
        while horas > 0:
            dia = list(dias.keys())[i % 5]
            if horas_dia[dia] < MAX_CLASES_POR_DIA:
                if (len(dias[dia]) >= 2 and
                    dias[dia][-1] != "DESCANSO" and
                    dias[dia][-2] != "DESCANSO" and
                    horas_dia[dia] <= 3 and
                    total_horas > 0):
                    dias[dia].append("DESCANSO")
                else:
                    dias[dia].append(materia)
                    horas_dia[dia] += 1
                    horas -= 1
                    total_horas -= 1
            else:
                i += 1
        i += 1
    return dias

"""
Descripción:
Asigna manualmente materias a días concretos respetando horas semanales y límites diarios.

Algoritmo:
1) Crear diccionario 'dias' vacío y contadores 'horas_dia'.
2) Mapear horas por materia desde 'materias'.
3) Para cada (materia, dia_in) en 'asignaciones':
   a) Normalizar el día.
   b) Repetir mientras haya horas por asignar y no se supere el límite diario:
      - Agregar la materia al día.
      - Decrementar horas y aumentar contador.
4) Retornar el diccionario 'dias'.
"""
def acomodo_manual_dias(materias: list[dict], asignaciones: list[tuple[str, str]]) -> dict:
    dias = {d: [] for d in DIAS}
    horas_dia = {d: 0 for d in dias}
    horas_map = {m["nombre"]: int(m["horas_semanales"]) for m in materias}

    for materia, dia_in in asignaciones:
        dia = normaliza_dia(dia_in)
        horas = horas_map.get(materia, 0)
        while horas > 0 and horas_dia[dia] < MAX_CLASES_POR_DIA:
            dias[dia].append(materia)
            horas_dia[dia] += 1
            horas -= 1
    return dias

"""
Descripción:
Produce una visualización por texto del acomodo diario resultante.

Algoritmo:
1) Inicializar una lista con el encabezado.
2) Para cada día en DIAS, agregar la lista de elementos asignados.
3) Retornar texto unido si as_text=True; de lo contrario, retornar lista.
"""
def mostrar_acomodo(dias: dict, as_text: bool = False):
    lines = ["--- Horario por día ---"]
    for d in DIAS:
        lines.append(f"{d}: {dias.get(d, [])}")
    return "\n".join(lines) if as_text else lines

# ------------------------------ MATRIZ SEMANAL ------------------------------

"""
Descripción:
Construye una matriz semanal 5 x SLOTS_POR_DIA inicializada con espacios libres.

Algoritmo:
1) Crear una lista de 5 filas.
2) En cada fila, crear SLOTS_POR_DIA elementos con valor LIBRE.
3) Retornar la matriz construida.
"""
def construir_matriz_vacia() -> list[list[str]]:
    return [[LIBRE for _ in range(SLOTS_POR_DIA)] for _ in range(len(DIAS))]

"""
Descripción:
Determina la longitud de la racha de clases al final de una fila de la matriz.

Algoritmo:
1) Recorrer la fila desde el final hacia el inicio.
2) Incrementar contador mientras no se encuentre LIBRE/DESCANSO/TAREA.
3) Detener cuando se halle uno de esos valores.
4) Retornar el contador acumulado.
"""
def consecutivos_clases_al_final(fila: list[str]) -> int:
    count = 0
    for celda in reversed(fila):
        if celda in (LIBRE, DESCANSO) or str(celda).startswith("TAREA:"):
            break
        count += 1
    return count

"""
Descripción:
Cuenta las celdas correspondientes a clases en una fila, excluyendo tareas y descansos.

Algoritmo:
1) Recorrer la fila.
2) Contar elementos que no sean LIBRE/DESCANSO ni empiecen con "TAREA:".
3) Retornar el total.
"""
def contar_clases_en_dia(fila: list[str]) -> int:
    return sum(1 for c in fila if c not in (LIBRE, DESCANSO) and not str(c).startswith("TAREA:"))

"""
Descripción:
Construye una salida tabular legible de la matriz semanal.

Algoritmo:
1) Crear encabezado con índices de slot.
2) Para cada fila/día:
   a) Truncar cada celda a 10 caracteres para visualización.
   b) Formatear la línea "Dia | c1 | c2 | ...".
3) Retornar el conjunto como texto o lista.
"""
def imprimir_matriz(matriz: list[list[str]], titulo: str = "Matriz semanal", as_text: bool = False):
    header = "Slot | " + " | ".join([f"{i:02d}" for i in range(SLOTS_POR_DIA)])
    lines = [f"--- {titulo} ---", header, "-" * len(header)]
    for d_idx, dia in enumerate(DIAS):
        fila = matriz[d_idx]
        contenido = " | ".join(f"{str(c)[:10]:10}" for c in fila)
        lines.append(f"{dia[:3]}  | {contenido}")
    return "\n".join(lines) if as_text else lines

"""
Descripción:
Distribuye automáticamente las materias en la matriz semanal considerando descansos.

Algoritmo:
1) Crear matriz vacía y un índice de día rotatorio.
2) Para cada materia:
   a) Mientras existan horas por colocar:
      i) Si el día actual tiene < MAX_CLASES_POR_DIA:
         - Si hay racha >=2 y hay LIBRE, insertar DESCANSO.
         - Si hay LIBRE, colocar nombre de materia y decrementar horas.
      ii) Avanzar al siguiente día (módulo 5).
3) Retornar la matriz resultante.
"""
def acomodo_automatico_matriz(materias: list[dict]) -> list[list[str]]:
    matriz = construir_matriz_vacia()
    dia_idx = 0
    for m in materias:
        nombre, horas = m["nombre"], int(m["horas_semanales"])
        while horas > 0:
            if contar_clases_en_dia(matriz[dia_idx]) < MAX_CLASES_POR_DIA:
                fila = matriz[dia_idx]
                if consecutivos_clases_al_final(fila) >= 2 and LIBRE in fila:
                    fila[fila.index(LIBRE)] = DESCANSO
                if LIBRE in fila:
                    fila[fila.index(LIBRE)] = nombre
                    horas -= 1
            dia_idx = (dia_idx + 1) % len(DIAS)
    return matriz

# ------------------------------ TAREAS -------------------------------------

__task_seq = 0

"""
Descripción:
Genera un identificador único para cada tarea registrada.

Algoritmo:
1) Incrementar un contador global.
2) Obtener timestamp actual en segundos.
3) Formatear y retornar "T{timestamp}{contador}".
"""
def _gen_tarea_id() -> str:
    global __task_seq
    __task_seq += 1
    return f"T{int(datetime.now().timestamp())}{__task_seq}"

"""
Descripción:
Crea la especificación estructurada de una tarea con sus metadatos académicos.

Algoritmo:
1) Normalizar 'tipo' y 'energia' contra catálogos permitidos.
2) Asegurar 'deps' y 'recurrente' como listas válidas.
3) Asegurar bloque_slots >= 1.
4) Construir y retornar el diccionario de la tarea con un id generado.
"""
def registrar_tarea_calendario(
    titulo: str, materia: str, horas_estimadas: int, deadline: datetime,
    tipo: str = "TAREA", prioridad: int = 3, dificultad: int = 2,
    energia: str = "MEDIA", deps: Optional[list[str]] = None,
    recurrente: Optional[list[str]] = None, bloque_slots: int = 1
) -> dict:
    tipo = (tipo or "TAREA").upper()
    if tipo not in TIPOS_TAREA:
        tipo = "TAREA"
    energia = (energia or "MEDIA").upper()
    if energia not in ENERGIAS:
        energia = "MEDIA"
    deps = deps or []
    recurrente = [d for d in (recurrente or []) if d in DIAS]
    return {
        "id": _gen_tarea_id(),
        "titulo": titulo.strip(),
        "materia": materia.strip(),
        "horas_estimadas": int(horas_estimadas),
        "deadline": deadline,
        "tipo": tipo,
        "prioridad": int(prioridad),
        "dificultad": int(dificultad),
        "energia": energia,
        "deps": deps,
        "recurrente": recurrente,
        "bloque_slots": max(1, int(bloque_slots)),
    }

"""
Descripción:
Cuenta la cantidad de bloques de tarea presentes en una fila de la matriz.

Algoritmo:
1) Recorrer la fila.
2) Contar celdas cuyo texto inicie con "TAREA:".
3) Retornar el total.
"""
def contar_tareas_en_dia(fila: list[str]) -> int:
    return sum(1 for c in fila if isinstance(c, str) and c.startswith("TAREA:"))

"""
Descripción:
Selecciona un slot libre apropiado para ubicar una tarea según la energía requerida.

Algoritmo:
1) Obtener índices de celdas LIBRE.
2) Si no hay disponibles → retornar None.
3) Si energia=ALTA → retornar el índice mínimo (temprano).
4) Si energia=BAJA → retornar el índice máximo (tarde).
5) Si energia=MEDIA → retornar el índice central.
"""
def encontrar_slot_para_tarea(fila: list[str], energia: str) -> Optional[int]:
    indices_libres = [i for i, c in enumerate(fila) if c == LIBRE]
    if not indices_libres:
        return None
    energia = energia.upper()
    if energia == "ALTA":
        return min(indices_libres)
    if energia == "BAJA":
        return max(indices_libres)
    return indices_libres[len(indices_libres)//2]

"""
Descripción:
Determina el número de bloques contiguos necesarios para completar una tarea.

Algoritmo:
1) Si bloque_slots <= 0 → fijar en 1.
2) Considerar 1 hora = 1 slot.
3) Calcular ceil(horas_estimadas / bloque_slots).
4) Retornar al menos 1 bloque.
"""
def bloques_necesarios(horas_estimadas: int, bloque_slots: int) -> int:
    if bloque_slots <= 0:
        bloque_slots = 1
    total_slots = horas_estimadas
    n_bloques = (total_slots + bloque_slots - 1) // bloque_slots
    return max(1, n_bloques)

"""
Descripción:
Integra tareas en la matriz de clases para construir un calendario semanal combinado.

Algoritmo:
1) Copiar la matriz de clases a 'combinado'.
2) Para cada tarea:
   a) Calcular número de bloques a colocar.
   b) Determinar día límite (hasta deadline.weekday() acotado a 4).
   c) Realizar hasta 3 rondas:
      i) Iterar días desde 0 hasta límite:
         - Buscar un slot con encontrar_slot_para_tarea.
         - Verificar contigüidad para 'bloque' slots.
         - Colocar la etiqueta "TAREA: ...".
         - Contabilizar bloques colocados; detener si se completan.
3) Retornar 'combinado'.
"""
def generar_calendario_tareas(
    matriz_clases: list[list[str]], tareas: list[dict], politica: str = "mixta"
) -> list[list[str]]:
    combinado = deepcopy(matriz_clases)
    for t in tareas:
        horas = int(t["horas_estimadas"])
        bloque = int(t.get("bloque_slots", 1))
        n_bloques = bloques_necesarios(horas, bloque)
        energia = t.get("energia", "MEDIA").upper()
        limite_dia = min(4, t["deadline"].weekday())
        bloques_colocados = 0
        for _ in range(3):
            for d in range(limite_dia + 1):
                if bloques_colocados >= n_bloques:
                    break
                fila = combinado[d]
                pos = encontrar_slot_para_tarea(fila, energia)
                if pos is None:
                    continue
                if pos + bloque > SLOTS_POR_DIA:
                    continue
                if any(fila[pos + k] != LIBRE for k in range(bloque)):
                    continue
                etiqueta = f"TAREA: {t['titulo']} ({t['materia']})"
                for k in range(bloque):
                    fila[pos + k] = etiqueta
                bloques_colocados += 1
            if bloques_colocados >= n_bloques:
                break
    return combinado

# ------------------------------ REPORTES -----------------------------------

"""
Descripción:
Calcula el resumen de carga (clases, tareas y espacios libres) por cada día de la semana.

Algoritmo:
1) Para cada día/fila de la matriz:
   a) Contar clases con contar_clases_en_dia.
   b) Contar tareas con contar_tareas_en_dia.
   c) Contar LIBRE.
2) Construir un dict {día: {clases, tareas, libres}}.
3) Retornar el resumen.
"""
def reporte_carga(matriz: list[list[str]]) -> dict:
    resumen = {}
    for d_idx, dia in enumerate(DIAS):
        fila = matriz[d_idx]
        clases = contar_clases_en_dia(fila)
        tareas = contar_tareas_en_dia(fila)
        libres = sum(1 for c in fila if c == LIBRE)
        resumen[dia] = {"clases": clases, "tareas": tareas, "libres": libres}
    return resumen

"""
Descripción:
Elabora un informe textual de la carga semanal a partir de la matriz proporcionada.

Algoritmo:
1) Obtener el resumen con reporte_carga.
2) Formatear una línea por cada día con (clases, tareas, libres).
3) Retornar el texto unido si as_text=True; en caso contrario, lista de líneas.
"""
def imprimir_reporte_carga(matriz: list[list[str]], as_text: bool = False):
    r = reporte_carga(matriz)
    lines = ["--- Carga semanal ---"]
    for dia in DIAS:
        data = r[dia]
        lines.append(f"{dia:10s}  clases: {data['clases']:2d} | tareas: {data['tareas']:2d} | libres: {data['libres']:2d}")
    return "\n".join(lines) if as_text else lines

"""
Descripción:
Persiste el estado del sistema (materias, matriz y tareas) en un archivo JSON.

Algoritmo:
1) Serializar materias y matriz directamente.
2) Convertir 'deadline' de cada tarea a string con formato "%Y-%m-%d %H:%M".
3) Escribir el objeto serializado a 'path' con indentación.
"""
def guardar_estado(path: str, materias: list[dict], matriz: list[list[str]], tareas: list[dict]) -> None:
    serial = {
        "materias": materias,
        "matriz": matriz,
        "tareas": [{**t, "deadline": t["deadline"].strftime("%Y-%m-%d %H:%M")} for t in tareas],
    }
    with open(path, "w", encoding="utf-8") as f:
        json.dump(serial, f, ensure_ascii=False, indent=2)

"""
Descripción:
Restaura el estado del sistema desde un archivo JSON previamente guardado.

Algoritmo:
1) Cargar el JSON desde 'path'.
2) Obtener 'materias', 'matriz' y 'tareas' (o valores por defecto).
3) Parsear 'deadline' de cada tarea al tipo datetime.
4) Retornar la tupla (materias, matriz, tareas).
"""
def cargar_estado(path: str) -> tuple[list[dict], list[list[str]], list[dict]]:
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
    materias = data.get("materias", [])
    matriz = data.get("matriz", construir_matriz_vacia())
    tareas = data.get("tareas", [])
    for t in tareas:
        t["deadline"] = datetime.strptime(t["deadline"], "%Y-%m-%d %H:%M")
    return materias, matriz, tareas


# ------------------------------ MAIN ---------------------------------------

"""
Descripción:
Ejecuta el flujo principal de interacción en consola orquestando las funciones del sistema.

Algoritmo:
1) Inicializar listas: materias, matriz_clases, tareas, calendario.
2) Bucle infinito:
   a) Mostrar menú y leer opción.
   b) Opción 1: registrar materias (ejemplo) y mostrarlas.
   c) Opción 2: generar matriz de clases automática y mostrarla.
   d) Opción 3: registrar tareas (ejemplo) y confirmar.
   e) Opción 4: generar calendario combinado y mostrarlo.
   f) Opción 5: imprimir reporte y guardar estado.
   g) Opción 0: salir del programa.
   h) Otras opciones: indicar inválida.
"""
def main():
    materias = []
    matriz_clases = []
    tareas = []
    calendario = []

    while True:
        menu()
        opcion = input("Selecciona una opción: ")

        if opcion == "1":
            materias = registrar_clases([
                {"nombre": "Cálculo", "horas_semanales": 3},
                {"nombre": "Física", "horas_semanales": 3},
                {"nombre": "Programación", "horas_semanales": 4},
            ])
            print(mostrar_clases(materias, as_text=True))

        elif opcion == "2":
            matriz_clases = acomodo_automatico_matriz(materias)
            print(imprimir_matriz(matriz_clases, as_text=True))

        elif opcion == "3":
            tareas = [
                registrar_tarea_calendario(
                    "Hoja de Derivadas", "Cálculo", 3, datetime(2025, 10, 18, 23, 59),
                    tipo="TAREA", prioridad=4, dificultad=2, energia="MEDIA"
                ),
                registrar_tarea_calendario(
                    "Estudiar Newton", "Física", 2, datetime(2025, 10, 17, 20, 0),
                    tipo="ESTUDIO", prioridad=5, dificultad=2, energia="ALTA"
                )
            ]
            print("\nTareas registradas correctamente.")

        elif opcion == "4":
            calendario = generar_calendario_tareas(matriz_clases, tareas)
            print(imprimir_matriz(calendario, "Calendario combinado", as_text=True))

        elif opcion == "5":
            print(imprimir_reporte_carga(calendario, as_text=True))
            guardar_estado("estado.json", materias, calendario, tareas)
            print("Estado guardado en 'estado.json'.")

        elif opcion == "0":
            print("Saliendo del programa...")
            break

        else:
            print("Opción inválida. Intenta nuevamente.")
main()
