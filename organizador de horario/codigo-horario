"""
Organizador de Horarios Universitarios

Permite registrar materias, generar horarios automáticos o manuales,
registrar tareas y combinarlas en un calendario semanal.
"""

from datetime import datetime, timedelta
from copy import deepcopy
import json
from typing import Optional

# ------------------------------ CONSTANTES ---------------------------------

DIAS = ["Lunes", "Martes", "Miércoles", "Jueves", "Viernes"]
SLOTS_POR_DIA = 8
MAX_CLASES_POR_DIA = 5
MAX_TAREAS_POR_DIA = 6
LIBRE = "LIBRE"
DESCANSO = "DESCANSO"

W_DEADLINE = 0.6
W_PRIORIDAD = 0.3
W_DIFICULTAD = 0.1

TIPOS_TAREA = {"TAREA", "ESTUDIO", "PROYECTO", "EXAMEN"}
ENERGIAS = {"BAJA", "MEDIA", "ALTA"}

# ------------------------------ FUNCIONES BASE ------------------------------

def normaliza_dia(entrada: str) -> str:
    """Normaliza el nombre de un día a uno válido."""
    if not entrada:
        return "Lunes"
    e = entrada.strip().capitalize()
    if e.startswith("Mier"):
        return "Miércoles"
    if e not in DIAS:
        return "Lunes"
    return e

def indice_dia(dia: str) -> int:
    """Devuelve el índice del día en la lista DIAS."""
    return DIAS.index(dia)

# ------------------------------ MATERIAS -----------------------------------

def registrar_clases(entradas: Optional[list[dict]] = None) -> list[dict]:
    """Registra materias a partir de una lista de diccionarios."""
    if entradas is None:
        raise ValueError("registrar_clases requiere 'entradas'.")
    out = []
    for i, m in enumerate(entradas, 1):
        nombre = (m.get("nombre") or f"Materia_{i}").strip()
        horas = int(m.get("horas_semanales", 0))
        out.append({"nombre": nombre, "horas_semanales": horas})
    return out

def mostrar_clases(materias: list[dict], as_text: bool = False):
    """Devuelve el listado de materias registradas."""
    lines = ["--- Horario de Clases ---"] if materias else ["No hay materias registradas."]
    for m in materias:
        lines.append(f"{m['nombre']}: {m['horas_semanales']} horas/semana")
    return "\n".join(lines) if as_text else lines

def materias_a_tuplas(materias: list[dict]) -> list[tuple[str, int]]:
    """Convierte la lista de materias en tuplas (nombre, horas)."""
    return [(m["nombre"], int(m["horas_semanales"])) for m in materias]

def acomodo_automatico_dias(materias: list[dict]) -> dict:
    """Distribuye automáticamente las materias por días."""
    dias = {d: [] for d in DIAS}
    horas_dia = {d: 0 for d in dias}
    i = 0
    tuplas = materias_a_tuplas(materias)
    total_horas = sum(h for _, h in tuplas)

    for materia, horas in tuplas:
        while horas > 0:
            dia = list(dias.keys())[i % 5]
            if horas_dia[dia] < MAX_CLASES_POR_DIA:
                if (len(dias[dia]) >= 2 and
                    dias[dia][-1] != "DESCANSO" and
                    dias[dia][-2] != "DESCANSO" and
                    horas_dia[dia] <= 3 and
                    total_horas > 0):
                    dias[dia].append("DESCANSO")
                else:
                    dias[dia].append(materia)
                    horas_dia[dia] += 1
                    horas -= 1
                    total_horas -= 1
            else:
                i += 1
        i += 1
    return dias

def acomodo_manual_dias(materias: list[dict], asignaciones: list[tuple[str, str]]) -> dict:
    """Asigna manualmente materias a días específicos."""
    dias = {d: [] for d in DIAS}
    horas_dia = {d: 0 for d in dias}
    horas_map = {m["nombre"]: int(m["horas_semanales"]) for m in materias}

    for materia, dia_in in asignaciones:
        dia = normaliza_dia(dia_in)
        horas = horas_map.get(materia, 0)
        while horas > 0 and horas_dia[dia] < MAX_CLASES_POR_DIA:
            dias[dia].append(materia)
            horas_dia[dia] += 1
            horas -= 1
    return dias

def mostrar_acomodo(dias: dict, as_text: bool = False):
    """Muestra el horario por días."""
    lines = ["--- Horario por día ---"]
    for d in DIAS:
        lines.append(f"{d}: {dias.get(d, [])}")
    return "\n".join(lines) if as_text else lines

# ------------------------------ MATRIZ SEMANAL ------------------------------

def construir_matriz_vacia() -> list[list[str]]:
    """Crea una matriz semanal vacía."""
    return [[LIBRE for _ in range(SLOTS_POR_DIA)] for _ in range(len(DIAS))]

def consecutivos_clases_al_final(fila: list[str]) -> int:
    """Cuenta cuántas clases consecutivas hay al final de una fila."""
    count = 0
    for celda in reversed(fila):
        if celda in (LIBRE, DESCANSO) or str(celda).startswith("TAREA:"):
            break
        count += 1
    return count

def contar_clases_en_dia(fila: list[str]) -> int:
    """Cuenta las clases en una fila (día)."""
    return sum(1 for c in fila if c not in (LIBRE, DESCANSO) and not str(c).startswith("TAREA:"))

def imprimir_matriz(matriz: list[list[str]], titulo: str = "Matriz semanal", as_text: bool = False):
    """Devuelve una representación de la matriz semanal."""
    header = "Slot | " + " | ".join([f"{i:02d}" for i in range(SLOTS_POR_DIA)])
    lines = [f"--- {titulo} ---", header, "-" * len(header)]
    for d_idx, dia in enumerate(DIAS):
        fila = matriz[d_idx]
        contenido = " | ".join(f"{str(c)[:10]:10}" for c in fila)
        lines.append(f"{dia[:3]}  | {contenido}")
    return "\n".join(lines) if as_text else lines

def acomodo_automatico_matriz(materias: list[dict]) -> list[list[str]]:
    """Distribuye automáticamente las materias en una matriz semanal."""
    matriz = construir_matriz_vacia()
    dia_idx = 0
    for m in materias:
        nombre, horas = m["nombre"], int(m["horas_semanales"])
        while horas > 0:
            if contar_clases_en_dia(matriz[dia_idx]) < MAX_CLASES_POR_DIA:
                fila = matriz[dia_idx]
                if consecutivos_clases_al_final(fila) >= 2 and LIBRE in fila:
                    fila[fila.index(LIBRE)] = DESCANSO
                if LIBRE in fila:
                    fila[fila.index(LIBRE)] = nombre
                    horas -= 1
            dia_idx = (dia_idx + 1) % len(DIAS)
    return matriz

# ------------------------------ TAREAS -------------------------------------

__task_seq = 0

def _gen_tarea_id() -> str:
    """Genera un identificador único para una tarea."""
    global __task_seq
    __task_seq += 1
    return f"T{int(datetime.now().timestamp())}{__task_seq}"

def registrar_tarea_calendario(
    titulo: str, materia: str, horas_estimadas: int, deadline: datetime,
    tipo: str = "TAREA", prioridad: int = 3, dificultad: int = 2,
    energia: str = "MEDIA", deps: Optional[list[str]] = None,
    recurrente: Optional[list[str]] = None, bloque_slots: int = 1
) -> dict:
    """Registra una tarea con sus atributos."""
    tipo = (tipo or "TAREA").upper()
    if tipo not in TIPOS_TAREA:
        tipo = "TAREA"
    energia = (energia or "MEDIA").upper()
    if energia not in ENERGIAS:
        energia = "MEDIA"
    deps = deps or []
    recurrente = [d for d in (recurrente or []) if d in DIAS]
    return {
        "id": _gen_tarea_id(),
        "titulo": titulo.strip(),
        "materia": materia.strip(),
        "horas_estimadas": int(horas_estimadas),
        "deadline": deadline,
        "tipo": tipo,
        "prioridad": int(prioridad),
        "dificultad": int(dificultad),
        "energia": energia,
        "deps": deps,
        "recurrente": recurrente,
        "bloque_slots": max(1, int(bloque_slots)),
    }

def contar_tareas_en_dia(fila: list[str]) -> int:
    """Cuenta las tareas asignadas en una fila de la matriz."""
    return sum(1 for c in fila if isinstance(c, str) and c.startswith("TAREA:"))

def encontrar_slot_para_tarea(fila: list[str], energia: str) -> Optional[int]:
    """Encuentra un slot libre adecuado para una tarea."""
    indices_libres = [i for i, c in enumerate(fila) if c == LIBRE]
    if not indices_libres:
        return None
    energia = energia.upper()
    if energia == "ALTA":
        return min(indices_libres)
    if energia == "BAJA":
        return max(indices_libres)
    return indices_libres[len(indices_libres)//2]

def bloques_necesarios(horas_estimadas: int, bloque_slots: int) -> int:
    """Calcula cuántos bloques requiere una tarea."""
    if bloque_slots <= 0:
        bloque_slots = 1
    total_slots = horas_estimadas
    n_bloques = (total_slots + bloque_slots - 1) // bloque_slots
    return max(1, n_bloques)

def generar_calendario_tareas(
    matriz_clases: list[list[str]], tareas: list[dict], politica: str = "mixta"
) -> list[list[str]]:
    """Combina clases y tareas en una matriz de calendario."""
    combinado = deepcopy(matriz_clases)
    for t in tareas:
        horas = int(t["horas_estimadas"])
        bloque = int(t.get("bloque_slots", 1))
        n_bloques = bloques_necesarios(horas, bloque)
        energia = t.get("energia", "MEDIA").upper()
        limite_dia = min(4, t["deadline"].weekday())
        bloques_colocados = 0
        for _ in range(3):
            for d in range(limite_dia + 1):
                if bloques_colocados >= n_bloques:
                    break
                fila = combinado[d]
                pos = encontrar_slot_para_tarea(fila, energia)
                if pos is None:
                    continue
                if pos + bloque > SLOTS_POR_DIA:
                    continue
                if any(fila[pos + k] != LIBRE for k in range(bloque)):
                    continue
                etiqueta = f"TAREA: {t['titulo']} ({t['materia']})"
                for k in range(bloque):
                    fila[pos + k] = etiqueta
                bloques_colocados += 1
            if bloques_colocados >= n_bloques:
                break
    return combinado

# ------------------------------ REPORTES -----------------------------------

def reporte_carga(matriz: list[list[str]]) -> dict:
    """Genera un reporte de clases, tareas y espacios libres por día."""
    resumen = {}
    for d_idx, dia in enumerate(DIAS):
        fila = matriz[d_idx]
        clases = contar_clases_en_dia(fila)
        tareas = contar_tareas_en_dia(fila)
        libres = sum(1 for c in fila if c == LIBRE)
        resumen[dia] = {"clases": clases, "tareas": tareas, "libres": libres}
    return resumen

def imprimir_reporte_carga(matriz: list[list[str]], as_text: bool = False):
    """Devuelve el reporte de carga semanal formateado."""
    r = reporte_carga(matriz)
    lines = ["--- Carga semanal ---"]
    for dia in DIAS:
        data = r[dia]
        lines.append(f"{dia:10s}  clases: {data['clases']:2d} | tareas: {data['tareas']:2d} | libres: {data['libres']:2d}")
    return "\n".join(lines) if as_text else lines

def guardar_estado(path: str, materias: list[dict], matriz: list[list[str]], tareas: list[dict]) -> None:
    """Guarda materias, matriz y tareas en formato JSON."""
    serial = {
        "materias": materias,
        "matriz": matriz,
        "tareas": [{**t, "deadline": t["deadline"].strftime("%Y-%m-%d %H:%M")} for t in tareas],
    }
    with open(path, "w", encoding="utf-8") as f:
        json.dump(serial, f, ensure_ascii=False, indent=2)

def cargar_estado(path: str) -> tuple[list[dict], list[list[str]], list[dict]]:
    """Carga materias, matriz y tareas desde un archivo JSON."""
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
    materias = data.get("materias", [])
    matriz = data.get("matriz", construir_matriz_vacia())
    tareas = data.get("tareas", [])
    for t in tareas:
        t["deadline"] = datetime.strptime(t["deadline"], "%Y-%m-%d %H:%M")
    return materias, matriz, tareas

def menu() -> None:
    """Muestra el menú principal del organizador."""
    print("\n=== ORGANIZADOR UNIVERSITARIO ===")
    print("1) Registrar/Mostrar materias")
    print("2) Acomodo clases (auto/manual)")
    print("3) Registrar/Mostrar tareas")
    print("4) Calendarizar (clases + tareas)")
    print("5) Reportes y Guardar/Cargar")
    print("0) Salir")

# ------------------------------ MAIN ---------------------------------------

def main():
    materias = []
    matriz_clases = []
    tareas = []
    calendario = []

    while True:
        menu()
        opcion = input("Selecciona una opción: ")

        if opcion == "1":
            materias = registrar_clases([
                {"nombre": "Cálculo", "horas_semanales": 3},
                {"nombre": "Física", "horas_semanales": 3},
                {"nombre": "Programación", "horas_semanales": 4},
            ])
            print(mostrar_clases(materias, as_text=True))

        elif opcion == "2":
            matriz_clases = acomodo_automatico_matriz(materias)
            print(imprimir_matriz(matriz_clases, as_text=True))

        elif opcion == "3":
            tareas = [
                registrar_tarea_calendario(
                    "Hoja de Derivadas", "Cálculo", 3, datetime(2025, 10, 18, 23, 59),
                    tipo="TAREA", prioridad=4, dificultad=2, energia="MEDIA"
                ),
                registrar_tarea_calendario(
                    "Estudiar Newton", "Física", 2, datetime(2025, 10, 17, 20, 0),
                    tipo="ESTUDIO", prioridad=5, dificultad=2, energia="ALTA"
                )
            ]
            print("\nTareas registradas correctamente.")

        elif opcion == "4":
            calendario = generar_calendario_tareas(matriz_clases, tareas)
            print(imprimir_matriz(calendario, "Calendario combinado", as_text=True))

        elif opcion == "5":
            print(imprimir_reporte_carga(calendario, as_text=True))
            guardar_estado("estado.json", materias, calendario, tareas)
            print("Estado guardado en 'estado.json'.")

        elif opcion == "0":
            print("Saliendo del programa...")
            break

        else:
            print("Opción inválida. Intenta nuevamente.")

if __name__ == "__main__":
    main()
